// Cylinder.cpp
#include "Cylinder.h"
#include <cmath>     // For sqrt, fabs, etc.
#include <limits>    // For numeric_limits
#include <algorithm> // For std::min and std::max
#include <iostream>  // For debugging

// Constructor implementation
Cylinder::Cylinder(const Vector3 &c, const Vector3 &a, float r, float h, const Material &m)
    : center(c), axis(a.normalise()), radius(r), height(h * 2.0f), material(m) // Double the height here
{
    if (h <= 0.0f)
    {
        std::cerr << "Warning: Cylinder height must be positive. Defaulting to height=1.0f.\n";
        height = 2.0f; // Default full height
    }
}

// Method to check ray-cylinder intersection and populate Intersection
bool Cylinder::intersect(const Ray &ray, Intersection &hit) const
{
    // Vector from cylinder center to ray origin
    Vector3 oc = ray.origin - center;

    // Project the ray direction and oc onto the plane perpendicular to the cylinder's axis
    float a = ray.direction.dot(ray.direction) - pow(ray.direction.dot(axis), 2);
    float b = 2.0f * (ray.direction.dot(oc) - ray.direction.dot(axis) * oc.dot(axis));
    float c = oc.dot(oc) - pow(oc.dot(axis), 2) - radius * radius;

    float discriminant = b * b - 4.0f * a * c;
    bool hitCylinderSide = false;
    float tSide = std::numeric_limits<float>::max();

    // Check for intersection with the side surface of the cylinder
    if (discriminant >= 0.0f)
    {
        float sqrtDisc = sqrt(discriminant);
        float t0 = (-b - sqrtDisc) / (2.0f * a);
        float t1 = (-b + sqrtDisc) / (2.0f * a);

        // Check both possible intersection points
        for (float tTemp : {t0, t1})
        {
            if (tTemp > 1e-4f) // Avoid self-intersection
            {
                Vector3 point = ray.origin + ray.direction * tTemp;
                // Project the point onto the cylinder axis
                float projection = (point - center).dot(axis);
                // Check if the point is within the cylinder's height bounds
                if (projection >= -height * 0.5f && projection <= height * 0.5f)
                {
                    if (tTemp < tSide)
                    {
                        tSide = tTemp;
                        hitCylinderSide = true;
                    }
                }
            }
        }
    }

    // Initialize to no intersection
    bool hitAnything = false;
    float tFinal = std::numeric_limits<float>::infinity();

    // If intersection with side surface is found
    if (hitCylinderSide && tSide < tFinal)
    {
        tFinal = tSide;
        hit.point = ray.origin + ray.direction * tFinal;

        // Compute the normal at the hit point
        Vector3 projection = axis * (hit.point - center).dot(axis);
        hit.normal = (hit.point - center - projection).normalise();

        hit.material = material;
        hit.distance = tFinal;

        // Compute UV coordinates for the cylinder side
        // Compute theta based on a reference axis (e.g., Vector3(1,0,0))
        Vector3 refAxis(1.0f, 0.0f, 0.0f);
        Vector3 orthogonal = refAxis.cross(axis);
        if (orthogonal.lengthSquared() < 1e-6f) // If axis is parallel to refAxis
            orthogonal = Vector3(0.0f, 1.0f, 0.0f).cross(axis);
        orthogonal = orthogonal.normalise();
        Vector3 tangent = axis.cross(orthogonal).normalise();

        float theta = std::atan2(hit.normal.dot(tangent), hit.normal.dot(orthogonal));
        if (theta < 0.0f)
            theta += 2.0f * M_PI;

        float u = theta / (2.0f * M_PI); // Range [0,1]

        // v_coord based on projection along axis
        float v_coord = (hit.point - center).dot(axis) / height + 0.5f; // Range [0,1]

        hit.u = u;
        hit.v = v_coord;

        hitAnything = true;

        // Debugging Output
        // std::cout << "Cylinder Side Hit: t=" << tFinal
        //           << ", Point=(" << hit.point.x << ", " << hit.point.y << ", " << hit.point.z << ")"
        //           << ", Normal=(" << hit.normal.x << ", " << hit.normal.y << ", " << hit.normal.z << ")\n";
    }

    // Check for intersection with the caps only if the cylinder has finite height
    if (height > 0.0f)
    {
        // Define cap normals
        Vector3 topCenter = center + axis * (height * 0.5f);
        Vector3 bottomCenter = center - axis * (height * 0.5f);
        Vector3 topNormal = axis;
        Vector3 bottomNormal = -axis;

        // Top cap intersection
        float denomTop = axis.dot(ray.direction);
        if (std::fabs(denomTop) > 1e-6f)
        {
            float tTop = (topCenter - ray.origin).dot(axis) / denomTop;
            if (tTop > 1e-4f && tTop < tFinal)
            {
                Vector3 pTop = ray.origin + ray.direction * tTop;
                Vector3 v = pTop - topCenter;
                if (v.dot(v) <= radius * radius)
                {
                    tFinal = tTop;
                    hit.point = pTop;
                    hit.normal = topNormal;
                    hit.material = material;
                    hit.distance = tFinal;

                    // Compute UV coordinates for the top cap
                    // Project v onto orthogonal and tangent vectors
                    Vector3 orthogonal_ref = Vector3(1.0f, 0.0f, 0.0f).cross(axis);
                    if (orthogonal_ref.lengthSquared() < 1e-6f) // If axis is parallel to refAxis
                        orthogonal_ref = Vector3(0.0f, 1.0f, 0.0f).cross(axis);
                    orthogonal_ref = orthogonal_ref.normalise();
                    Vector3 tangent_ref = axis.cross(orthogonal_ref).normalise();

                    float u_cap = (v.dot(orthogonal_ref) / radius) * 0.5f + 0.5f;
                    float v_cap = (v.dot(tangent_ref) / radius) * 0.5f + 0.5f;

                    hit.u = u_cap;
                    hit.v = v_cap;

                    hitAnything = true;

                    // Debugging Output
                    // std::cout << "Cylinder Top Cap Hit: t=" << tFinal
                    //           << ", Point=(" << hit.point.x << ", " << hit.point.y << ", " << hit.point.z << ")"
                    //           << ", Normal=(" << hit.normal.x << ", " << hit.normal.y << ", " << hit.normal.z << ")\n";
                }
            }
        }

        // Bottom cap intersection
        float denomBottom = axis.dot(ray.direction);
        if (std::fabs(denomBottom) > 1e-6f)
        {
            float tBottom = (bottomCenter - ray.origin).dot(axis) / denomBottom;
            if (tBottom > 1e-4f && tBottom < tFinal)
            {
                Vector3 pBottom = ray.origin + ray.direction * tBottom;
                Vector3 v = pBottom - bottomCenter;
                if (v.dot(v) <= radius * radius)
                {
                    tFinal = tBottom;
                    hit.point = pBottom;
                    hit.normal = bottomNormal;
                    hit.material = material;
                    hit.distance = tFinal;

                    // Compute UV coordinates for the bottom cap
                    // Project v onto orthogonal and tangent vectors
                    Vector3 orthogonal_ref = Vector3(1.0f, 0.0f, 0.0f).cross(axis);
                    if (orthogonal_ref.lengthSquared() < 1e-6f) // If axis is parallel to refAxis
                        orthogonal_ref = Vector3(0.0f, 1.0f, 0.0f).cross(axis);
                    orthogonal_ref = orthogonal_ref.normalise();
                    Vector3 tangent_ref = axis.cross(orthogonal_ref).normalise();

                    float u_cap = (v.dot(orthogonal_ref) / radius) * 0.5f + 0.5f;
                    float v_cap = (v.dot(tangent_ref) / radius) * 0.5f + 0.5f;

                    hit.u = u_cap;
                    hit.v = v_cap;

                    hitAnything = true;

                    // Debugging Output
                    // std::cout << "Cylinder Bottom Cap Hit: t=" << tFinal
                    //           << ", Point=(" << hit.point.x << ", " << hit.point.y << ", " << hit.point.z << ")"
                    //           << ", Normal=(" << hit.normal.x << ", " << hit.normal.y << ", " << hit.normal.z << ")\n";
                }
            }
        }
    }

    return hitAnything;
}

// Method to get the normal at a point on the cylinder
Vector3 Cylinder::getNormal(const Vector3 &point) const
{
    // Compute the normal based on the cylinder's axis
    Vector3 projection = axis * (point - center).dot(axis);
    Vector3 normal = (point - center - projection).normalise();
    return normal;
}

// Get the bounding box of the cylinder
BoundingBox Cylinder::getBoundingBox() const
{
    // Compute the bounding box based on the cylinder's axis and height
    float halfHeight = height * 0.5f;
    Vector3 topCenter = center + axis * halfHeight;
    Vector3 bottomCenter = center - axis * halfHeight;

    // Determine the orthogonal vectors to the axis for bounding calculations
    Vector3 refAxis(1.0f, 0.0f, 0.0f);
    Vector3 orthogonal = refAxis.cross(axis);
    if (orthogonal.lengthSquared() < 1e-6f) // If axis is parallel to refAxis
        orthogonal = Vector3(0.0f, 1.0f, 0.0f).cross(axis);
    orthogonal = orthogonal.normalise();
    Vector3 tangent = axis.cross(orthogonal).normalise();

    // Points on the top and bottom circles
    Vector3 topPoints[4] = {
        topCenter + orthogonal * radius,
        topCenter - orthogonal * radius,
        topCenter + tangent * radius,
        topCenter - tangent * radius};

    Vector3 bottomPoints[4] = {
        bottomCenter + orthogonal * radius,
        bottomCenter - orthogonal * radius,
        bottomCenter + tangent * radius,
        bottomCenter - tangent * radius};

    // Initialize min and max points
    Vector3 minPt = topPoints[0];
    Vector3 maxPt = topPoints[0];

    for (int i = 0; i < 4; ++i)
    {
        minPt = Vector3::min(minPt, topPoints[i]);
        maxPt = Vector3::max(maxPt, topPoints[i]);
        minPt = Vector3::min(minPt, bottomPoints[i]);
        maxPt = Vector3::max(maxPt, bottomPoints[i]);
    }

    BoundingBox box(minPt, maxPt);

    return box;
}

// SceneLoader.cpp
#include "SceneLoader.h"
#include "Sphere.h"
#include "Cylinder.h"
#include "Triangle.h"
#include "Material.h"
#include "Color.h"
#include "CheckerboardTexture.h"
#include <fstream>
#include <iostream>

// Function to align any vector to Y-axis (simplified)
Vector3 alignToYAxis(const Vector3 &)
{
    // For simplicity, set the axis to Y-axis directly
    return Vector3(0.0f, 1.0f, 0.0f);
}

// Function to rotate a vector to align with the Y-axis
Vector3 rotateToYAxis(const Vector3 &)
{
    // For simplicity, return Y-axis directly
    return Vector3(0.0f, 1.0f, 0.0f);
}

// Loads the entire scene from a JSON file and populates the Scene object
bool SceneLoader::loadScene(const std::string &filePath, Scene &scene)
{
    std::ifstream sceneFile(filePath);
    if (!sceneFile.is_open())
    {
        std::cerr << "Could not open file: " << filePath << std::endl;
        return false;
    }

    json sceneData;
    try
    {
        sceneFile >> sceneData;
    }
    catch (const json::parse_error &e)
    {
        std::cerr << "JSON parse error: " << e.what() << std::endl;
        return false;
    }

    // Load Render Mode
    scene.renderMode = sceneData.value("rendermode", "binary");

    // Load nbounces if available
    scene.nbounces = sceneData.value("nbounces", 1);

    // Load Camera
    if (sceneData.contains("camera"))
    {
        scene.camera = loadCamera(sceneData["camera"]);
    }
    else
    {
        std::cerr << "Camera data missing in JSON file." << std::endl;
        return false;
    }

    // Load Background Color
    if (sceneData.contains("scene") && sceneData["scene"].contains("backgroundcolor"))
    {
        auto bg = sceneData["scene"]["backgroundcolor"];
        if (bg.is_array() && bg.size() == 3)
        {
            scene.backgroundColor = Color(bg[0], bg[1], bg[2]);
        }
        else
        {
            std::cerr << "Invalid backgroundColor format. Using default." << std::endl;
        }
    }

    // Load Lights
    if (sceneData["scene"].contains("lightsources"))
    {
        scene.lights = loadLights(sceneData["scene"]["lightsources"]);
    }

    // Load Objects
    if (sceneData["scene"].contains("shapes"))
    {
        auto shapesData = sceneData["scene"]["shapes"];
        for (const auto &shape : shapesData)
        {
            auto obj = loadObject(shape);
            if (obj)
            {
                // Removed the automatic axis alignment for cylinders
                scene.addObject(obj);
            }
        }
    }
    else
    {
        std::cerr << "Shapes data missing in JSON file." << std::endl;
        return false;
    }

    return true;
}

// Load Camera
Camera SceneLoader::loadCamera(const json &cameraData)
{
    Vector3 position(cameraData["position"][0], cameraData["position"][1], cameraData["position"][2]);
    Vector3 lookAt(cameraData["lookAt"][0], cameraData["lookAt"][1], cameraData["lookAt"][2]);
    Vector3 upVector(cameraData["upVector"][0], cameraData["upVector"][1], cameraData["upVector"][2]);
    float fov = cameraData["fov"];
    int width = cameraData["width"];
    int height = cameraData["height"];
    float exposure = cameraData.value("exposure", 1.0f); // Default exposure if not specified

    return Camera(position, lookAt, upVector, fov, width, height, exposure);
}

// Loads light sources
std::vector<Light> SceneLoader::loadLights(const json &lightsData)
{
    std::vector<Light> lights;
    for (const auto &light : lightsData)
    {
        if (light.contains("position") && light.contains("intensity"))
        {
            Vector3 position(light["position"][0], light["position"][1], light["position"][2]);
            Color intensity(light["intensity"][0], light["intensity"][1], light["intensity"][2]);
            lights.emplace_back(position, intensity); // Assuming a Light constructor that takes position and intensity
        }
        else
        {
            std::cerr << "Invalid light source format. Skipping." << std::endl;
        }
    }
    return lights;
}

// Helper to load material properties
Material SceneLoader::loadMaterial(const json &materialData)
{
    Material material;
    // Map JSON fields to Material properties
    // Scene.json uses:
    // "ks": specular coefficient (float)
    // "kd": diffuse coefficient (float)
    // "specularexponent": specular exponent (float)
    // "diffusecolor": [r, g, b]
    // "specularcolor": [r, g, b]
    // "isreflective": bool
    // "reflectivity": float
    // "isrefractive": bool
    // "refractiveindex": float

    // Set diffuse color
    if (materialData.contains("diffusecolor") && materialData["diffusecolor"].is_array() && materialData["diffusecolor"].size() == 3)
    {
        material.diffuseColor = Color(materialData["diffusecolor"][0], materialData["diffusecolor"][1], materialData["diffusecolor"][2]);
    }
    else
    {
        // Default diffuse color
        material.diffuseColor = Color(0.5f, 0.5f, 0.5f);
    }

    // Set specular color
    if (materialData.contains("specularcolor") && materialData["specularcolor"].is_array() && materialData["specularcolor"].size() == 3)
    {
        material.specularColor = Color(materialData["specularcolor"][0], materialData["specularcolor"][1], materialData["specularcolor"][2]);
    }
    else
    {
        // Default specular color
        material.specularColor = Color(1.0f, 1.0f, 1.0f);
    }

    // Set shininess
    if (materialData.contains("specularexponent"))
    {
        material.specularExponent = materialData["specularexponent"];
    }
    else
    {
        // Default shininess
        material.specularExponent = 32.0f;
    }

    // Load texture if present
    if (materialData.contains("texture"))
    {
        auto textureData = materialData["texture"];
        if (textureData.contains("type"))
        {
            std::string textureType = textureData["type"];
            if (textureType == "checkerboard")
            {
                Color color1(1.0f, 1.0f, 1.0f);
                Color color2(0.0f, 0.0f, 0.0f);
                float scale = 1.0f;
                if (textureData.contains("color1") && textureData["color1"].is_array() && textureData["color1"].size() == 3)
                {
                    color1 = Color(textureData["color1"][0], textureData["color1"][1], textureData["color1"][2]);
                }
                if (textureData.contains("color2") && textureData["color2"].is_array() && textureData["color2"].size() == 3)
                {
                    color2 = Color(textureData["color2"][0], textureData["color2"][1], textureData["color2"][2]);
                }
                if (textureData.contains("scale"))
                {
                    scale = textureData["scale"];
                }
                material.texture = std::make_shared<CheckerboardTexture>(color1, color2, scale);
            }
            else
            {
                std::cerr << "Unknown texture type: " << textureType << ". Skipping texture." << std::endl;
            }
        }
    }

    // Set diffuse coefficient
    material.kd = materialData.value("kd", 0.9f);

    // Set specular coefficient
    material.ks = materialData.value("ks", 0.1f);

    // Derive ambient color as diffuseColor * kd
    material.ambient = material.diffuseColor * material.kd;

    // Set reflectivity
    material.isReflective = materialData.value("isreflective", false);
    if (material.isReflective)
    {
        material.reflectivity = materialData.value("reflectivity", 0.0f);
    }
    else
    {
        material.reflectivity = 0.0f;
    }

    // Set refractive properties
    material.isRefractive = materialData.value("isrefractive", false);
    if (material.isRefractive)
    {
        material.refractiveIndex = materialData.value("refractiveindex", 1.0f);
    }
    else
    {
        material.refractiveIndex = 1.0f;
    }

    return material;
}

// Loads a single object (Sphere, Cylinder, Triangle)
std::shared_ptr<Object> SceneLoader::loadObject(const json &shapeData)
{
    if (!shapeData.contains("type"))
    {
        std::cerr << "Shape type missing. Skipping object." << std::endl;
        return nullptr;
    }

    std::string type = shapeData["type"];
    Material material = Material(); // Default material
    if (shapeData.contains("material"))
    {
        material = loadMaterial(shapeData["material"]);
    }

    if (type == "sphere")
    {
        if (shapeData.contains("center") && shapeData.contains("radius"))
        {
            Vector3 center(shapeData["center"][0], shapeData["center"][1], shapeData["center"][2]);
            float radius = shapeData["radius"];
            return std::make_shared<Sphere>(center, radius, material);
        }
        else
        {
            std::cerr << "Invalid sphere format. Skipping object." << std::endl;
            return nullptr;
        }
    }
    else if (type == "cylinder")
    {
        if (shapeData.contains("center") && shapeData.contains("axis") && shapeData.contains("radius") && shapeData.contains("height"))
        {
            Vector3 center(shapeData["center"][0], shapeData["center"][1], shapeData["center"][2]);
            Vector3 axis(shapeData["axis"][0], shapeData["axis"][1], shapeData["axis"][2]);
            float radius = shapeData["radius"];
            float height = shapeData["height"];
            return std::make_shared<Cylinder>(center, axis, radius, height, material);
        }
        else
        {
            std::cerr << "Invalid cylinder format. Skipping object." << std::endl;
            return nullptr;
        }
    }
    else if (type == "triangle")
    {
        if (shapeData.contains("v0") && shapeData.contains("v1") && shapeData.contains("v2"))
        {
            Vector3 v0(shapeData["v0"][0], shapeData["v0"][1], shapeData["v0"][2]);
            Vector3 v1(shapeData["v1"][0], shapeData["v1"][1], shapeData["v1"][2]);
            Vector3 v2(shapeData["v2"][0], shapeData["v2"][1], shapeData["v2"][2]);

            // Load UV coordinates if available
            Vector3 uv0(0.0f, 0.0f, 0.0f);
            Vector3 uv1(1.0f, 0.0f, 0.0f);
            Vector3 uv2(0.0f, 1.0f, 0.0f);
            if (shapeData.contains("uv0") && shapeData["uv0"].is_array() && shapeData["uv0"].size() >= 2)
            {
                uv0 = Vector3(shapeData["uv0"][0], shapeData["uv0"][1], 0.0f);
            }
            if (shapeData.contains("uv1") && shapeData["uv1"].is_array() && shapeData["uv1"].size() >= 2)
            {
                uv1 = Vector3(shapeData["uv1"][0], shapeData["uv1"][1], 0.0f);
            }
            if (shapeData.contains("uv2") && shapeData["uv2"].is_array() && shapeData["uv2"].size() >= 2)
            {
                uv2 = Vector3(shapeData["uv2"][0], shapeData["uv2"][1], 0.0f);
            }

            return std::make_shared<Triangle>(v0, v1, v2, material, uv0, uv1, uv2);
        }
        else
        {
            std::cerr << "Invalid triangle format. Skipping object." << std::endl;
            return nullptr;
        }
    }
    else
    {
        std::cerr << "Unknown shape type: " << type << ". Skipping object." << std::endl;
        return nullptr;
    }
}

#include "Image.h"
#include <fstream>
#include <mutex>

// Mutex for thread safety
std::mutex imageMutex;

Image::Image() : width(0), height(0), pixels()
{
    // Initialize to an empty image or set default values if necessary
}

Image::Image(int width, int height) : width(width), height(height), pixels(width * height) {}

void Image::setPixel(int x, int y, const Color &color)
{
    if (x >= 0 && x < width && y >= 0 && y < height)
    {
        // Lock the mutex for thread-safe access
        std::lock_guard<std::mutex> lock(imageMutex);
        pixels[y * width + x] = color;
    }
}

Color Image::getPixel(int x, int y) const
{
    if (x >= 0 && x < width && y >= 0 && y < height)
    {
        return pixels[y * width + x];
    }
    return Color(); // Return default black color if out of bounds
}

bool Image::saveAsPPM(const std::string &filename) const
{
    std::ofstream file(filename);
    if (!file.is_open())
        return false;

    file << "P3\n"
         << width << " " << height << "\n255\n";
    for (const auto &color : pixels)
    {
        file << static_cast<int>(255.99 * color.r) << " "
             << static_cast<int>(255.99 * color.g) << " "
             << static_cast<int>(255.99 * color.b) << "\n";
    }
    file.close();
    return true;
}

// Scene.cpp
#include "Scene.h"
#include "BVHNode.h"
#include <limits>
#include <iostream>

void Scene::buildBVH()
{
    if (objects.empty())
    {
        bvhRoot = nullptr;
        return;
    }

    bvhRoot = std::make_shared<BVHNode>(objects, 0, objects.size());
}

bool Scene::intersect(const Ray &ray, Intersection &closestHit) const
{
    if (!bvhRoot)
        return false;

    // Initialize closestHit.distance to infinity
    closestHit.distance = std::numeric_limits<float>::infinity();

    bool hit = bvhRoot->intersect(ray, closestHit);

    return hit;
}

// Vector3.cpp
#include "Vector3.h"
#include <cmath>     // for std::fabs, std::sqrt
#include <algorithm> // for std::min, std::max

// Addition
Vector3 Vector3::operator+(const Vector3 &other) const
{
    return Vector3(x + other.x, y + other.y, z + other.z);
}

// Subtraction
Vector3 Vector3::operator-(const Vector3 &other) const
{
    return Vector3(x - other.x, y - other.y, z - other.z);
}

// Scalar multiplication
Vector3 Vector3::operator*(float scalar) const
{
    return Vector3(x * scalar, y * scalar, z * scalar);
}

// Scalar division
Vector3 Vector3::operator/(float scalar) const
{
    if (scalar == 0.0f)
        throw std::runtime_error("Division by zero in Vector3::operator/");

    return Vector3(x / scalar, y / scalar, z / scalar);
}

// Compound Assignment Operators
Vector3 &Vector3::operator+=(const Vector3 &other)
{
    x += other.x;
    y += other.y;
    z += other.z;
    return *this;
}

Vector3 &Vector3::operator-=(const Vector3 &other)
{
    x -= other.x;
    y -= other.y;
    z -= other.z;
    return *this;
}

Vector3 &Vector3::operator*=(float scalar)
{
    x *= scalar;
    y *= scalar;
    z *= scalar;
    return *this;
}

Vector3 &Vector3::operator/=(float scalar)
{
    if (scalar == 0.0f)
        throw std::runtime_error("Division by zero in Vector3::operator/=");

    x /= scalar;
    y /= scalar;
    z /= scalar;
    return *this;
}

// Element-wise multiplication
Vector3 Vector3::operator*(const Vector3 &other) const
{
    return Vector3(x * other.x, y * other.y, z * other.z);
}

// Unary Minus Operator
Vector3 Vector3::operator-() const
{
    return Vector3(-x, -y, -z);
}

// Dot product
float Vector3::dot(const Vector3 &other) const
{
    return x * other.x + y * other.y + z * other.z;
}

// Cross product
Vector3 Vector3::cross(const Vector3 &other) const
{
    return Vector3(
        y * other.z - z * other.y,
        z * other.x - x * other.z,
        x * other.y - y * other.x);
}

// Normalize
Vector3 Vector3::normalise() const
{
    float len = length();
    if (len == 0.0f)
        return Vector3(0.0f, 0.0f, 0.0f); // Prevent division by zero
    return (*this) / len;
}

// Length
float Vector3::length() const
{
    return std::sqrt(x * x + y * y + z * z);
}

// Length Squared
float Vector3::lengthSquared() const
{
    return x * x + y * y + z * z;
}

// Clamp
Vector3 Vector3::clamp(float min_val, float max_val) const
{
    float clampedX = std::fmax(min_val, std::fmin(x, max_val));
    float clampedY = std::fmax(min_val, std::fmin(y, max_val));
    float clampedZ = std::fmax(min_val, std::fmin(z, max_val));
    return Vector3(clampedX, clampedY, clampedZ);
}

// Equality operator with tolerance for floating-point precision
bool Vector3::operator==(const Vector3 &other) const
{
    const float tolerance = 1e-5f;
    return (std::fabs(x - other.x) < tolerance) &&
           (std::fabs(y - other.y) < tolerance) &&
           (std::fabs(z - other.z) < tolerance);
}

// Inequality operator
bool Vector3::operator!=(const Vector3 &other) const
{
    return !(*this == other);
}

// Element access - non-const
float &Vector3::operator[](int index)
{
    if (index == 0)
        return x;
    else if (index == 1)
        return y;
    else if (index == 2)
        return z;
    else
    {
        throw std::out_of_range("Index out of range for Vector3");
    }
}

// Element access - const
const float &Vector3::operator[](int index) const
{
    if (index == 0)
        return x;
    else if (index == 1)
        return y;
    else if (index == 2)
        return z;
    else
    {
        throw std::out_of_range("Index out of range for Vector3");
    }
}

// Static methods for component-wise min and max
Vector3 Vector3::min(const Vector3 &a, const Vector3 &b)
{
    return Vector3(
        std::min(a.x, b.x),
        std::min(a.y, b.y),
        std::min(a.z, b.z));
}

Vector3 Vector3::max(const Vector3 &a, const Vector3 &b)
{
    return Vector3(
        std::max(a.x, b.x),
        std::max(a.y, b.y),
        std::max(a.z, b.z));
}

// Reflect
Vector3 Vector3::reflect(const Vector3 &normal) const
{
    return *this - normal * (2.0f * this->dot(normal));
}

// Refraction
Vector3 Vector3::refract(const Vector3 &normal, float eta) const
{
    // Snell's Law: eta = n_i / n_t
    float cosi = std::max(-1.0f, std::min(1.0f, this->dot(normal)));
    float etai = 1.0f, etat = eta;
    Vector3 n = normal;
    if (cosi < 0)
    {
        cosi = -cosi;
    }
    else
    {
        std::swap(etai, etat);
        n = -normal;
    }
    float eta_ratio = etai / etat;
    float k = 1.0f - eta_ratio * eta_ratio * (1.0f - cosi * cosi);
    if (k < 0)
        return Vector3(0.0f, 0.0f, 0.0f); // Total internal reflection
    else
        return (*this) * eta_ratio + n * (eta_ratio * cosi - std::sqrt(k));
}

// Debug print method
void Vector3::print() const
{
    std::cout << "Vector3(" << x << ", " << y << ", " << z << ")" << std::endl;
}

// Stream insertion operator for outputting to std::ostream
std::ostream &operator<<(std::ostream &os, const Vector3 &v)
{
    os << "Vector3(" << v.x << ", " << v.y << ", " << v.z << ")";
    return os;
}

// Raytracer.cpp
#include "Raytracer.h"
#include "BlinnPhongShader.h"
#include <iostream>
#include <algorithm>
#include <omp.h>
#include <chrono>
#include <cmath> // Include for std::pow

Raytracer::Raytracer(int width, int height) : image(width, height)
{
    // Initialization if necessary
}

void Raytracer::render(const Scene &scene, const std::string &outputFilename)
{
    const Camera &camera = scene.camera;
    int width = camera.width;
    int height = camera.height;
    image = Image(width, height);

    bool isBinaryMode = scene.renderMode == "binary";

    // Initialize the shader once
    BlinnPhongShader shader(scene, scene.camera.position);

    // Start timing
    auto startTime = std::chrono::steady_clock::now();

    // Retrieve exposure from camera
    float exposure = camera.exposure;

    // Iterate over each pixel with OpenMP parallelization
#pragma omp parallel for schedule(dynamic) shared(image)
    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            Ray ray = camera.generateRay(static_cast<float>(x), static_cast<float>(y));

            // Trace the ray and compute the color
            Color color = trace(ray, scene, shader, 0);

            if (isBinaryMode)
            {
                // In binary mode, trace already returns red or background
                // So no need to modify color here
            }
            else
            {
                // Apply exposure adjustment using exposure value as EV (Exposure Value)
                // Using pow(2.0f, exposure) to scale brightness appropriately
                color *= std::pow(2.0f, exposure);

                // Apply filmic tone mapping
                color = color.toneMap();

                // Optionally adjust saturation (set to 1.2 for increased saturation)
                color = color.adjustSaturation(1.2f); // Increase saturation by 20%

                // Apply gamma correction
                color = color.gammaCorrect(2.2f);

                // Clamp color between 0 and 1
                color = color.clamp(0.0f, 1.0f);
            }

            // Set the pixel color (assumes thread-safe)
            image.setPixel(x, y, color);
        }

        // Calculate and display progress every 100 lines or on the last line
#pragma omp critical
        {
            if (y % 100 == 0 || y == height - 1)
            {
                auto currentTime = std::chrono::steady_clock::now();
                std::chrono::duration<double> elapsed = currentTime - startTime;
                double progress = (static_cast<double>(y) / height) * 100.0;
                std::cout << "\rRendering Progress: " << progress << "% | Elapsed Time: " << elapsed.count() << "s" << std::flush;
            }
        }
    }

    std::cout << std::endl; // Move to the next line after progress output

    // Save the rendered image to the specified file
    if (image.saveAsPPM(outputFilename))
    {
        std::cout << "Rendering completed. Image saved to " << outputFilename << std::endl;
    }
    else
    {
        std::cerr << "Failed to save image to " << outputFilename << std::endl;
    }
}

Color Raytracer::trace(const Ray &ray, const Scene &scene, const BlinnPhongShader &shader, int depth) const
{
    // Check if the render mode is "binary"
    bool isBinaryMode = scene.renderMode == "binary";

    if (isBinaryMode)
    {
        Intersection hit;
        bool hasHit = scene.intersect(ray, hit);
        if (hasHit)
        {
            // Return fixed color (e.g., red) for any intersection
            return Color(1.0f, 0.0f, 0.0f);
        }
        else
        {
            // Return background color if no intersection
            return scene.backgroundColor;
        }
    }

    // Existing trace logic for non-binary modes
    if (depth >= scene.nbounces)
        return Color(0, 0, 0); // Base case: no further contribution

    Intersection closestHit;
    bool hit = scene.intersect(ray, closestHit);

    if (hit)
    {
        // Compute the color at the intersection point using the shader
        Color shadedColor = shader.shade(closestHit);

        // Initialize accumulated color with the shaded color
        Color accumulatedColor = shadedColor;

        // Handle reflections if the material is reflective
        if (closestHit.material.isReflective && closestHit.material.reflectivity > 0.0f)
        {
            Vector3 reflectedDir = ray.direction.reflect(closestHit.normal).normalise();
            Ray reflectedRay(closestHit.point + closestHit.normal * 1e-4f, reflectedDir);
            Color reflectedColor = trace(reflectedRay, scene, shader, depth + 1);

            // Blend the reflected color with the current accumulated color
            float reflectivity = closestHit.material.reflectivity;
            accumulatedColor = accumulatedColor * (1.0f - reflectivity) + reflectedColor * reflectivity;
        }

        // Handle refractions if the material is refractive
        if (closestHit.material.isRefractive)
        {
            float transmission = 1.0f - closestHit.material.reflectivity;
            if (transmission > 0.0f)
            {
                float eta = closestHit.material.refractiveIndex;
                Vector3 normal = closestHit.normal;
                float cosi = normal.dot(ray.direction);
                float etai = 1.0f, etat = eta;

                if (cosi > 0)
                {
                    // Ray is inside the object, swap indices and invert normal
                    std::swap(etai, etat);
                    normal = -normal;
                }
                float etaRatio = etai / etat;

                // Calculate the refracted direction
                float k = 1 - etaRatio * etaRatio * (1 - cosi * cosi);
                Vector3 refractedDir;
                if (k < 0)
                {
                    // Total internal reflection
                    refractedDir = ray.direction.reflect(normal);
                }
                else
                {
                    refractedDir = ray.direction * etaRatio + normal * (etaRatio * cosi - sqrtf(k));
                }

                refractedDir = refractedDir.normalise();
                Ray refractedRay(closestHit.point - normal * 1e-4f, refractedDir);
                Color refractedColor = trace(refractedRay, scene, shader, depth + 1);

                // Blend the refracted color with the accumulated color
                accumulatedColor = accumulatedColor * (1.0f - transmission) + refractedColor * transmission;
            }
        }

        // Return the accumulated color without tone mapping
        return accumulatedColor;
    }
    else
    {
        // No intersection; return the scene's background color without tone mapping
        return scene.backgroundColor;
    }
}

Color Raytracer::getPixelColor(int x, int y) const
{
    return image.getPixel(x, y);
}

#include "Camera.h"
#include <cmath>
#include <iostream>

Camera::Camera(const Vector3 &position, const Vector3 &lookAt, const Vector3 &up, float fov, int width, int height, float exposure)
    : position(position), lookAt(lookAt), exposure(exposure), width(width), height(height)
{
    // Calculate aspect ratio from width and height
    aspectRatio = static_cast<float>(width) / height;

    // Calculate the forward, right, and up directions based on lookAt and up
    forward = (lookAt - position).normalise();
    right = forward.cross(up).normalise();
    this->up = right.cross(forward).normalise();

    // Convert the field of view to radians
    this->fov = (fov * M_PI) / 180.0f;
}

// Generate a ray from the camera through the viewport at the specified pixel coordinates
Ray Camera::generateRay(float pixelX, float pixelY) const
{
    // Calculate the viewport scaling based on the FOV
    float scale = std::tan(fov / 2.0f);

    // Normalize pixel coordinates to the range [-1, 1] for viewport space
    float x = (-2 * (pixelX + 0.5f) / width + 1) * aspectRatio * scale;
    float y = (1 - 2 * (pixelY + 0.5f) / height) * scale;

    // Calculate the direction of the ray through the pixel
    Vector3 direction = (forward + right * x + up * y).normalise();

    Ray ray(position, direction);
    // std::cout << "Generated Ray Origin: (" << ray.origin.x << ", " << ray.origin.y << ", " << ray.origin.z << ") "
    //           << "Direction: (" << ray.direction.x << ", " << ray.direction.y << ", " << ray.direction.z << ")\n";
    return ray;
}

#include "Light.h"

Light::Light(const Vector3 &position, const Color &intensity)
    : position(position), intensity(intensity) {}

#include "Ray.h"

// Constructor to initialise the ray with an origin and a direction
Ray::Ray(const Vector3 &origin, const Vector3 &direction) : origin(origin), direction(direction.normalise()) {}

// Method to get point along the ray: origin + t * direction
Vector3 Ray::at(float t) const
{
    return origin + direction * t;
};
#include "Color.h"

// All methods are defined inline in Color.h for efficiency.

// CheckerboardTexture.cpp
#include "CheckerboardTexture.h"
#include <cmath>

Color CheckerboardTexture::getColor(float u, float v) const
{
    // Ensure u and v wrap around [0,1]
    u = u - std::floor(u);
    v = v - std::floor(v);

    int checkU = static_cast<int>(std::floor(u * scale)) % 2;
    int checkV = static_cast<int>(std::floor(v * scale)) % 2;
    if ((checkU + checkV) % 2 == 0)
    {
        return color1;
    }
    else
    {
        return color2;
    }
}

// BlinnPhongShader.cpp
#include "BlinnPhongShader.h"
#include "Ray.h"
#include <algorithm>
#include <cmath>

BlinnPhongShader::BlinnPhongShader(const Scene &scene, const Vector3 &cameraPos)
    : scene(scene), cameraPosition(cameraPos) {}

Color BlinnPhongShader::shade(const Intersection &hit) const
{
    Color finalColor(0, 0, 0); // Initialize to black

    // Use texture color if available
    Color diffuseColor = hit.material.diffuseColor;
    if (hit.material.texture)
    {
        diffuseColor = hit.material.texture->getColor(hit.u, hit.v);
    }

    Vector3 viewDir = (cameraPosition - hit.point).normalise();
    Vector3 normal = hit.normal.normalise();

    // Ambient component with a fixed intensity
    Color ambient = diffuseColor * hit.material.kd * 0.1f; // Ambient intensity is 0.1

    finalColor += ambient; // Add ambient component to final color

    for (const auto &light : scene.lights)
    {
        Vector3 lightDir = (light.getPosition() - hit.point).normalise();
        float lightDistance = (light.getPosition() - hit.point).length();

        if (isInShadow(hit.point, lightDir, lightDistance))
        {
            // Skip diffuse and specular contributions from this light
            continue;
        }

        // Diffuse shading
        float diff = std::max(normal.dot(lightDir), 0.0f);
        Color diffuse = diffuseColor * hit.material.kd * diff;

        // Specular shading using Blinn-Phong model
        Vector3 halfDir = (lightDir + viewDir).normalise();
        float specAngle = std::max(normal.dot(halfDir), 0.0f);
        float spec = std::pow(specAngle, hit.material.specularExponent);
        Color specular = hit.material.specularColor * hit.material.ks * spec;

        // Adjusted attenuation to prevent excessive darkening
        // Using a linear + quadratic attenuation model
        float attenuation = 1.0f / (1.0f + 0.7f * lightDistance + 1.8f * lightDistance * lightDistance);

        // Multiply by light intensity
        Color lightIntensity = light.getIntensity();

        // Add contributions from this light
        finalColor += (diffuse + specular) * lightIntensity * attenuation;
    }

    // Do not clamp here; allow high dynamic range values
    return finalColor;
}

bool BlinnPhongShader::isInShadow(const Vector3 &point, const Vector3 &lightDir, float lightDistance) const
{
    const float shadowBias = 1e-4f; // Small bias to prevent self-shadowing
    Ray shadowRay(point + lightDir * shadowBias, lightDir);

    // Check for intersection with BVH
    Intersection shadowHit;
    if (scene.intersect(shadowRay, shadowHit))
    {
        if (shadowHit.distance < lightDistance)
        {
            return true; // Point is in shadow
        }
    }

    return false; // Point is illuminated
}

// BoundingBox.cpp
#include "BoundingBox.h"
#include <limits>
#include <algorithm>
#include <cmath>

BoundingBox::BoundingBox()
    : minPoint(Vector3(std::numeric_limits<float>::max(),
                       std::numeric_limits<float>::max(),
                       std::numeric_limits<float>::max())),
      maxPoint(Vector3(std::numeric_limits<float>::lowest(),
                       std::numeric_limits<float>::lowest(),
                       std::numeric_limits<float>::lowest())) {}

BoundingBox::BoundingBox(const Vector3 &min, const Vector3 &max)
    : minPoint(min), maxPoint(max) {}

bool BoundingBox::intersect(const Ray &ray, float t_min, float t_max) const
{
    for (int i = 0; i < 3; ++i)
    {
        float invD = 1.0f / ray.direction[i];
        float t0 = (minPoint[i] - ray.origin[i]) * invD;
        float t1 = (maxPoint[i] - ray.origin[i]) * invD;
        if (invD < 0.0f)
            std::swap(t0, t1);
        t_min = t0 > t_min ? t0 : t_min;
        t_max = t1 < t_max ? t1 : t_max;
        // Changed condition to allow t_max == t_min
        if (t_max < t_min)
            return false;
    }
    return true;
}

void BoundingBox::expand(const BoundingBox &box)
{
    minPoint = Vector3::min(minPoint, box.minPoint);
    maxPoint = Vector3::max(maxPoint, box.maxPoint);
}

void BoundingBox::expand(const Vector3 &point)
{
    minPoint = Vector3::min(minPoint, point);
    maxPoint = Vector3::max(maxPoint, point);
}

// BVHNode.cpp
#include "BVHNode.h"
#include <algorithm>
#include <limits>
#include <cstdlib> // For rand()
#include <iostream>

// Default constructor implementation
BVHNode::BVHNode() : left(nullptr), right(nullptr), object(nullptr) {}

// Helper function to select the axis with the largest extent
int BVHNode::selectAxis(const Vector3 &extent) const
{
    if (extent.x >= extent.y && extent.x >= extent.z)
        return 0; // X-axis
    else if (extent.y >= extent.x && extent.y >= extent.z)
        return 1; // Y-axis
    else
        return 2; // Z-axis
}

// BVHNode constructor that builds the BVH tree
BVHNode::BVHNode(std::vector<std::shared_ptr<Object>> &objects, size_t start, size_t end)
{
    // Compute the bounding box for all objects in this node
    box = objects[start]->getBoundingBox();
    for (size_t i = start + 1; i < end; ++i)
    {
        box.expand(objects[i]->getBoundingBox());
    }

    size_t objectSpan = end - start;

    if (objectSpan == 1)
    {
        // Leaf node
        object = objects[start];
        left = right = nullptr;
    }
    else
    {
        // Determine the axis with the largest extent
        Vector3 extent = box.getMax() - box.getMin();
        int axis = selectAxis(extent);

        // Sort objects based on the chosen axis
        std::sort(objects.begin() + start, objects.begin() + end, [axis](const std::shared_ptr<Object> &a, const std::shared_ptr<Object> &b)
                  { return a->getBoundingBox().getMin()[axis] < b->getBoundingBox().getMin()[axis]; });

        // Find the midpoint to split the objects
        size_t mid = start + objectSpan / 2;

        // Recursively build the left and right child nodes
        left = std::make_shared<BVHNode>(objects, start, mid);
        right = std::make_shared<BVHNode>(objects, mid, end);
    }
}

// Intersection method implementation
bool BVHNode::intersect(const Ray &ray, Intersection &hit) const
{
    if (!box.intersect(ray, 0.001f, hit.distance))
        return false;

    bool hitSomething = false;

    if (object)
    {
        // Leaf node: check intersection with the single object
        Intersection tempHit;
        if (object->intersect(ray, tempHit))
        {
            if (tempHit.distance < hit.distance)
            {
                hit = tempHit;
                hitSomething = true;
            }
        }
    }
    else
    {
        // Internal node: check intersection with both children
        if (left && left->intersect(ray, hit))
            hitSomething = true;
        if (right && right->intersect(ray, hit))
            hitSomething = true;
    }

    return hitSomething;
}

// Triangle.cpp
#include "Triangle.h"
#include <cmath>     // For fabs and other math functions
#include <algorithm> // For std::min and std::max

bool Triangle::intersect(const Ray &ray, Intersection &hit) const
{
    const float EPSILON = 1e-8f;
    Vector3 edge1 = v1 - v0;
    Vector3 edge2 = v2 - v0;

    Vector3 h = ray.direction.cross(edge2);
    float a = edge1.dot(h);

    if (std::fabs(a) < EPSILON)
        return false; // Ray is parallel to the triangle

    float f = 1.0f / a;
    Vector3 s = ray.origin - v0;
    float u = f * s.dot(h);

    if (u < 0.0f || u > 1.0f)
        return false;

    Vector3 q = s.cross(edge1);
    float v = f * ray.direction.dot(q);

    if (v < 0.0f || (u + v) > 1.0f)
        return false;

    float t_val = f * edge2.dot(q);

    if (t_val > EPSILON)
    { // Ray intersection
        hit.distance = t_val;
        hit.point = ray.origin + ray.direction * t_val;

        // Compute the normal and ensure it's facing the ray
        Vector3 normal = edge1.cross(edge2).normalise();
        if (ray.direction.dot(normal) > 0)
            normal = -normal; // Flip normal if it's facing away

        hit.normal = normal;
        hit.material = material;

        // Store barycentric coordinates for potential texture mapping
        hit.u = u;
        hit.v = v;

        return true;
    }
    else
    { // Line intersection but not a ray intersection
        return false;
    }
}

BoundingBox Triangle::getBoundingBox() const
{
    Vector3 minPoint = Vector3(
        std::min({v0.x, v1.x, v2.x}),
        std::min({v0.y, v1.y, v2.y}),
        std::min({v0.z, v1.z, v2.z}));

    Vector3 maxPoint = Vector3(
        std::max({v0.x, v1.x, v2.x}),
        std::max({v0.y, v1.y, v2.y}),
        std::max({v0.z, v1.z, v2.z}));

    // Add a small epsilon to ensure the bounding box has non-zero thickness
    const float epsilon = 1e-4f;
    minPoint = minPoint - Vector3(epsilon, epsilon, epsilon);
    maxPoint = maxPoint + Vector3(epsilon, epsilon, epsilon);

    return BoundingBox(minPoint, maxPoint);
}

// Sphere.cpp
#include "Sphere.h"
#include <cmath> // For sqrt and atan2

bool Sphere::intersect(const Ray &ray, Intersection &hit) const
{
    Vector3 oc = ray.origin - center;
    float a = ray.direction.dot(ray.direction);
    float b = 2.0f * oc.dot(ray.direction);
    float c = oc.dot(oc) - radius * radius;
    float discriminant = b * b - 4 * a * c;

    if (discriminant < 0.0f)
        return false;

    float sqrtDisc = sqrt(discriminant);
    float t0 = (-b - sqrtDisc) / (2.0f * a);
    float t1 = (-b + sqrtDisc) / (2.0f * a);

    if (t0 > t1)
        std::swap(t0, t1);

    float t;
    if (t0 > 1e-4f)
    {
        t = t0;
    }
    else if (t1 > 1e-4f)
    {
        t = t1;
    }
    else
    {
        return false;
    }

    hit.distance = t;
    hit.point = ray.origin + ray.direction * t;
    hit.normal = (hit.point - center).normalise();
    hit.material = material;

    // Compute UV coordinates for texture mapping
    Vector3 p = (hit.point - center).normalise(); // Point on unit sphere
    float u = 0.5f + (std::atan2(p.z, p.x) / (2.0f * M_PI));
    float v = 0.5f - (std::asin(p.y) / M_PI);

    hit.u = u;
    hit.v = v;

    return true;
}

BoundingBox Sphere::getBoundingBox() const
{
    Vector3 minPoint = center - Vector3(radius, radius, radius);
    Vector3 maxPoint = center + Vector3(radius, radius, radius);
    return BoundingBox(minPoint, maxPoint);
}
#include "Plane.h"
#include "Ray.h"
#include <cmath>

bool Plane::intersect(const Ray &ray, Intersection &hit) const
{
    float denom = normal.dot(ray.direction);
    if (std::fabs(denom) > 1e-6)
    {
        float t = (point - ray.origin).dot(normal) / denom;
        if (t > 0)
        {
            hit.point = ray.origin + ray.direction * t;
            hit.normal = normal;
            hit.material = material;
            hit.distance = t;
            return true;
        }
    }
    return false;
}

#include "SceneLoader.h"
#include "Raytracer.h"
#include <iostream>
#include <vector>
#include <string>
#include <chrono>

// Function to render a single scene
void renderScene(const std::string &inputJson, const std::string &outputPpm)
{
    SceneLoader loader;
    Scene scene;

    std::cout << "Loading scene: " << inputJson << std::endl;

    // Load the scene from the JSON file
    if (!loader.loadScene(inputJson, scene))
    {
        std::cerr << "Failed to load scene from " << inputJson << std::endl;
        return;
    }

    std::cout << "Successfully loaded " << inputJson << std::endl;

    // Build the Bounding Volume Hierarchy (BVH) for the scene
    scene.buildBVH();

    // Initialize Raytracer with the camera's resolution
    Raytracer raytracer(scene.camera.width, scene.camera.height);

    // Render the scene and save the output PPM file
    raytracer.render(scene, outputPpm);
}

int main(int argc, char *argv[])
{
    // Check for at least one scene file
    if (argc < 3 || argc % 2 != 1)
    {
        std::cerr << "Usage: " << argv[0] << " <input_json1> <output_ppm1> [<input_json2> <output_ppm2> ...]" << std::endl;
        return 1;
    }

    // Process each pair of input JSON and output PPM
    for (int i = 1; i < argc; i += 2)
    {
        std::string inputJson = argv[i];
        std::string outputPpm = argv[i + 1];
        renderScene(inputJson, outputPpm);
    }

    std::cout << "All scenes have been processed." << std::endl;

    return 0;
}

// CheckerboardTexture.h
#ifndef CHECKERBOARD_TEXTURE_H
#define CHECKERBOARD_TEXTURE_H

#include "Texture.h"
#include <memory>

class CheckerboardTexture : public Texture
{
public:
    CheckerboardTexture(const Color &color1, const Color &color2, float scale = 1.0f)
        : color1(color1), color2(color2), scale(scale) {}

    Color getColor(float u, float v) const override;

private:
    Color color1;
    Color color2;
    float scale;
};

#endif // CHECKERBOARD_TEXTURE_H

#ifndef BLINN_PHONG_SHADER_H
#define BLINN_PHONG_SHADER_H

#include "Scene.h"
#include "Intersection.h"
#include "Color.h"

class BlinnPhongShader
{
public:
    BlinnPhongShader(const Scene &scene, const Vector3 &cameraPos);

    Color shade(const Intersection &hit) const;

private:
    const Scene &scene;
    Vector3 cameraPosition;

    // Check if a point is in shadow
    bool isInShadow(const Vector3 &point, const Vector3 &lightDir, float lightDistance) const;
};

#endif // BLINN_PHONG_SHADER_H

// Intersection.h
#ifndef INTERSECTION_H
#define INTERSECTION_H

#include "Vector3.h"
#include "Material.h" // Include Material

struct Intersection
{
    Vector3 point;     // Intersection point
    Vector3 normal;    // Normal at the intersection point
    Material material; // Material of the intersected object
    float distance;    // Distance from the ray origin to the intersection point

    float u; // U coordinate for texture mapping
    float v; // V coordinate for texture mapping
};

#endif // INTERSECTION_H

#ifndef LIGHT_H
#define LIGHT_H

#include "Vector3.h"
#include "Color.h"

class Light
{
public:
    // Constructor to initialize position and intensity
    Light(const Vector3 &position, const Color &intensity);

    // Getters
    Vector3 getPosition() const { return position; }
    Color getIntensity() const { return intensity; }

private:
    Vector3 position; // Position of the light in the scene
    Color intensity;  // Intensity (color and brightness) of the light
};

#endif // LIGHT_H

// BoundingBox.h
#ifndef BOUNDING_BOX_H
#define BOUNDING_BOX_H

#include "Vector3.h"
#include "Ray.h"

class BoundingBox
{
public:
    BoundingBox();
    BoundingBox(const Vector3 &min, const Vector3 &max);

    // Check if the ray intersects the bounding box
    bool intersect(const Ray &ray, float t_min, float t_max) const;

    // Expand the bounding box to include another bounding box
    void expand(const BoundingBox &box);

    // Expand the bounding box to include a point
    void expand(const Vector3 &point);

    // Getters
    Vector3 getMin() const { return minPoint; }
    Vector3 getMax() const { return maxPoint; }

private:
    Vector3 minPoint;
    Vector3 maxPoint;
};

#endif // BOUNDING_BOX_H

#ifndef CAMERA_H
#define CAMERA_H

#include "Vector3.h"
#include "Ray.h"

class Camera
{
public:
    // Default constructor
    Camera()
        : position(0.0f, 0.0f, 0.0f),
          lookAt(0.0f, 0.0f, -1.0f),
          forward(0.0f, 0.0f, -1.0f),
          up(0.0f, 1.0f, 0.0f),
          right(1.0f, 0.0f, 0.0f),
          fov(45.0f),
          aspectRatio(1.0f),
          exposure(1.0f),
          width(800),
          height(600)
    {
    }

    // Constructor with parameters
    Camera(const Vector3 &position, const Vector3 &lookAt, const Vector3 &up, float fov, int width, int height, float exposure);

    // Generate a ray from the camera through a viewport pixel
    Ray generateRay(float pixelX, float pixelY) const;

    // Method to update resolution and recompute directional vectors
    void setResolution(int newWidth, int newHeight)
    {
        width = newWidth;
        height = newHeight;
        aspectRatio = static_cast<float>(width) / height;
        right = forward.cross(up).normalise();
        this->up = right.cross(forward).normalise();
    }

    // Camera attributes
    Vector3 position;
    Vector3 lookAt; // Added lookAt member
    Vector3 forward, up, right;
    float fov;
    float aspectRatio;
    float exposure;
    int width;  // Image width
    int height; // Image height
};

#endif // CAMERA_H

// Sphere.h
#ifndef SPHERE_H
#define SPHERE_H

#include "Vector3.h"
#include "Ray.h"
#include "Material.h"
#include "Intersection.h" // Include Intersection
#include "Object.h"       // Assuming Sphere inherits from Object

class Sphere : public Object // Inheriting from a base Object class
{
public:
    // Constructor with material
    Sphere(const Vector3 &c, float r, const Material &m)
        : center(c), radius(r), material(m) {}

    // Intersection method that fills in the Intersection data if there's an intersection
    bool intersect(const Ray &ray, Intersection &hit) const override;

    // Getters
    const Vector3 &getCenter() const { return center; }
    float getRadius() const { return radius; }
    const Material &getMaterial() const { return material; }

    // Get the bounding box of the sphere
    BoundingBox getBoundingBox() const override;

private:
    Vector3 center;    // Center of Sphere
    float radius;      // Radius of Sphere
    Material material; // Material of Sphere
};

#endif // SPHERE_H

// SceneLoader.h
#ifndef SCENELOADER_H
#define SCENELOADER_H

#include <vector>
#include <string>
#include <memory>
#include "nlohmann/json.hpp"
#include "Scene.h"   // Updated to include Scene
#include "Light.h"   // Light class
#include "Color.h"   // Color struct
#include "Vector3.h" // Vector3 class

using json = nlohmann::json;

class SceneLoader
{
public:
    // Default constructor
    SceneLoader() {}

    // Loads the scene from a JSON file and populates the Scene object
    bool loadScene(const std::string &filePath, Scene &scene);

private:
    // Helper methods for loading different components
    Camera loadCamera(const json &cameraData);
    std::shared_ptr<Object> loadObject(const json &shapeData);
    std::vector<Light> loadLights(const json &lightsData); // Loads light sources
    Material loadMaterial(const json &materialData);       // Loads material properties
};

#endif // SCENELOADER_H

// Cylinder.h
#ifndef CYLINDER_H
#define CYLINDER_H

#include "Vector3.h"      // Custom Vector3 class for 3D vectors
#include "Ray.h"          // Ray class
#include "Material.h"     // Material class
#include "Intersection.h" // Intersection structure
#include "Object.h"       // Base class for objects
#include "BoundingBox.h"  // BoundingBox class

class Cylinder : public Object
{
public:
    // Constructor with material
    // 'height' is treated as the full height of the cylinder
    Cylinder(const Vector3 &center, const Vector3 &axis, float radius, float height, const Material &material);

    // Method to check ray-cylinder intersection and populate Intersection
    bool intersect(const Ray &ray, Intersection &hit) const override;

    // Getters
    const Vector3 &getCenter() const { return center; }
    const Vector3 &getAxis() const { return axis; }
    float getRadius() const { return radius; }
    float getHeight() const { return height; }
    const Material &getMaterial() const { return material; }

    // Get the bounding box of the cylinder
    BoundingBox getBoundingBox() const override;

private:
    // Method to get the normal at a point on the cylinder
    Vector3 getNormal(const Vector3 &point) const;

    // Attributes
    Vector3 center;    // Center point of the cylinder (midpoint)
    Vector3 axis;      // Normalized axis vector of the cylinder
    float radius;      // Radius of the cylinder
    float height;      // Full height of the cylinder
    Material material; // Material property for rendering
};

#endif // CYLINDER_H

// Material.h
#ifndef MATERIAL_H
#define MATERIAL_H

#include "Color.h"
#include <memory>
#include "Texture.h"

class Material
{
public:
    // Default constructor with typical default values
    Material()
        : ks(0.0f), kd(1.0f), specularExponent(1.0f),
          ambient(0.1f, 0.1f, 0.1f),
          diffuseColor(1.0f, 1.0f, 1.0f), specularColor(1.0f, 1.0f, 1.0f),
          isReflective(false), reflectivity(0.0f),
          isRefractive(false), refractiveIndex(1.0f),
          texture(nullptr) {}

    // Material properties
    float ks;               // Specular coefficient
    float kd;               // Diffuse coefficient
    float specularExponent; // Specular exponent for shininess
    Color ambient;          // Ambient color
    Color diffuseColor;     // Diffuse color
    Color specularColor;    // Specular color
    bool isReflective;      // Reflective flag
    float reflectivity;     // Reflectivity factor
    bool isRefractive;      // Refractive flag
    float refractiveIndex;  // Refractive index

    // Texture
    std::shared_ptr<Texture> texture;
};

#endif // MATERIAL_H

// Color.h
#ifndef COLOR_H
#define COLOR_H

#include <algorithm>
#include <iostream>
#include <cmath>

struct Color
{
    float r, g, b;

    // Constructors
    Color() : r(0.0f), g(0.0f), b(0.0f) {}
    Color(float red, float green, float blue) : r(red), g(green), b(blue) {}

    // Operator overloads
    Color operator+(const Color &other) const;
    Color &operator+=(const Color &other);
    Color operator*(float scalar) const;
    Color &operator*=(float scalar);
    Color operator*(const Color &other) const;

    // Clamp method
    Color clamp(float minVal, float maxVal) const;

    // Tone mapping using Filmic operator
    Color toneMap() const;

    // Gamma correction
    Color gammaCorrect(float gamma) const;

    // Adjust saturation
    Color adjustSaturation(float saturation) const;
};

// Addition
inline Color Color::operator+(const Color &other) const
{
    return Color(r + other.r, g + other.g, b + other.b);
}

inline Color &Color::operator+=(const Color &other)
{
    r += other.r;
    g += other.g;
    b += other.b;
    return *this;
}

// Scalar multiplication
inline Color Color::operator*(float scalar) const
{
    return Color(r * scalar, g * scalar, b * scalar);
}

inline Color &Color::operator*=(float scalar)
{
    r *= scalar;
    g *= scalar;
    b *= scalar;
    return *this;
}

// Element-wise multiplication
inline Color Color::operator*(const Color &other) const
{
    return Color(r * other.r, g * other.g, b * other.b);
}

// Clamp color components between min and max
inline Color Color::clamp(float minVal, float maxVal) const
{
    return Color(
        std::max(minVal, std::min(r, maxVal)),
        std::max(minVal, std::min(g, maxVal)),
        std::max(minVal, std::min(b, maxVal)));
}

// Filmic tone mapping operator (Uncharted 2)
inline Color Color::toneMap() const
{
    auto Uncharted2Tonemap = [](float x) -> float
    {
        const float A = 0.15f;
        const float B = 0.50f;
        const float C = 0.10f;
        const float D = 0.20f;
        const float E = 0.02f;
        const float F = 0.30f;
        return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
    };

    return Color(
        Uncharted2Tonemap(r),
        Uncharted2Tonemap(g),
        Uncharted2Tonemap(b));
}

// Gamma correction
inline Color Color::gammaCorrect(float gamma) const
{
    float invGamma = 1.0f / gamma;
    return Color(
        std::pow(std::max(r, 0.0f), invGamma),
        std::pow(std::max(g, 0.0f), invGamma),
        std::pow(std::max(b, 0.0f), invGamma));
}

// Adjust saturation
inline Color Color::adjustSaturation(float saturation) const
{
    // Convert to grayscale using luminosity method
    float gray = 0.2126f * r + 0.7152f * g + 0.0722f * b;
    return Color(
        gray + (r - gray) * saturation,
        gray + (g - gray) * saturation,
        gray + (b - gray) * saturation);
}

#endif // COLOR_H

#ifndef PLANE_H
#define PLANE_H

#include "Object.h"
#include "Vector3.h"
#include "Material.h"

class Plane : public Object
{
public:
    Plane(const Vector3 &point, const Vector3 &normal, const Material &material)
        : point(point), normal(normal.normalise()), material(material) {}

    bool intersect(const Ray &ray, Intersection &hit) const override;

private:
    Vector3 point;  // A point on the plane
    Vector3 normal; // Normal to the plane
    Material material;
};

#endif // PLANE_H

// BVHNode.h
#ifndef BVH_NODE_H
#define BVH_NODE_H

#include "BoundingBox.h"
#include "Object.h"
#include "Ray.h"
#include "Intersection.h"
#include <vector>
#include <memory>

class BVHNode
{
public:
    // Default constructor
    BVHNode();

    // Constructor that builds the BVH node from a list of objects
    // Accepts a non-const reference to allow sorting
    BVHNode(std::vector<std::shared_ptr<Object>> &objects, size_t start, size_t end);

    // Check for intersection with the BVH node
    bool intersect(const Ray &ray, Intersection &hit) const;

private:
    BoundingBox box;                // Bounding box for this node
    std::shared_ptr<BVHNode> left;  // Left child
    std::shared_ptr<BVHNode> right; // Right child
    std::shared_ptr<Object> object; // For leaf nodes

    // Helper function to select the axis with the largest extent
    int selectAxis(const Vector3 &extent) const;
};

#endif // BVH_NODE_H

#ifndef RAY_H
#define RAY_H

#include "Vector3.h"

class Ray
{
public:
    Vector3 origin;    // Starting point of the ray
    Vector3 direction; // Direction of the ray

    // Constructor
    Ray(const Vector3 &origin, const Vector3 &direction);

    // Method to compute a point along the ray at a given distance (t)
    Vector3 at(float t) const;
};

#endif
// Object.h
#ifndef OBJECT_H
#define OBJECT_H

#include "Ray.h"
#include "Intersection.h"
#include "BoundingBox.h"

class Object
{
public:
    virtual ~Object() {}

    // Pure virtual intersect method to be implemented by derived classes
    virtual bool intersect(const Ray &ray, Intersection &hit) const = 0;

    // Virtual method to get the bounding box of the object
    virtual BoundingBox getBoundingBox() const = 0;
};

#endif // OBJECT_H

// Triangle.h
#ifndef TRIANGLE_H
#define TRIANGLE_H

#include "Vector3.h"
#include "Ray.h"
#include "Material.h"
#include "Intersection.h"
#include "Object.h"
#include "BoundingBox.h"

class Triangle : public Object
{
public:
    // Constructor with material and optional UV coordinates
    Triangle(const Vector3 &vertex0, const Vector3 &vertex1, const Vector3 &vertex2, const Material &m,
             const Vector3 &uv0 = Vector3(0, 0, 0), const Vector3 &uv1 = Vector3(1, 0, 0), const Vector3 &uv2 = Vector3(0, 1, 0))
        : v0(vertex0), v1(vertex1), v2(vertex2), uv0(uv0), uv1(uv1), uv2(uv2), material(m) {}

    // Intersection method overridden from Object
    bool intersect(const Ray &ray, Intersection &hit) const override;

    // Get the bounding box of the triangle
    BoundingBox getBoundingBox() const override;

private:
    // Triangle vertices
    Vector3 v0, v1, v2;

    // UV coordinates at each vertex
    Vector3 uv0, uv1, uv2;

    // Material of the triangle
    Material material;
};

#endif // TRIANGLE_H

// Texture.h
#ifndef TEXTURE_H
#define TEXTURE_H

#include "Color.h"

class Texture
{
public:
    virtual ~Texture() {}

    // Given UV coordinates, return the color
    virtual Color getColor(float u, float v) const = 0;
};

#endif // TEXTURE_H

// include/Image.h
#ifndef IMAGE_H
#define IMAGE_H

#include "Color.h"
#include <vector>
#include <string>

class Image
{
public:
    Image();
    Image(int width, int height);

    void setPixel(int x, int y, const Color &color);
    Color getPixel(int x, int y) const;
    bool saveAsPPM(const std::string &filename) const;

private:
    int width;
    int height;
    std::vector<Color> pixels;
};

#endif // IMAGE_H

#ifndef RAYTRACER_H
#define RAYTRACER_H

#ifdef __APPLE__
#include <libkern/OSByteOrder.h>
#define htobe16(x) OSSwapHostToBigInt16(x)
#define be16toh(x) OSSwapBigToHostInt16(x)
#define htobe32(x) OSSwapHostToBigInt32(x)
#define be32toh(x) OSSwapBigToHostInt32(x)
#define htobe64(x) OSSwapHostToBigInt64(x)
#define be64toh(x) OSSwapBigToHostInt64(x)
#else
#include <endian.h>
#endif

#include "Vector3.h"
#include "Ray.h"
#include "Intersection.h"
#include "BlinnPhongShader.h"
#include "Scene.h"
#include "Image.h"
#include <string>

// Forward declaration to avoid circular dependency
class BlinnPhongShader;

class Raytracer
{
public:
    // Constructor with width and height
    Raytracer(int width, int height);

    // Render the scene and save the output image
    void render(const Scene &scene, const std::string &outputFilename);

    // Trace a ray into the scene and compute the color, supporting recursion for reflections/refractions
    Color trace(const Ray &ray, const Scene &scene, const BlinnPhongShader &shader, int depth = 0) const;

    // Access the rendered image (for testing purposes)
    Image getImage() const { return image; }

    Color getPixelColor(int x, int y) const;

private:
    Image image;
};

#endif // RAYTRACER_H

// Vector3.h
#ifndef VECTOR3_H
#define VECTOR3_H

#include <iostream>
#include <cmath>
#include <stdexcept>

class Vector3
{
public:
    float x, y, z;

    // Constructors
    Vector3() : x(0.0f), y(0.0f), z(0.0f) {}
    Vector3(float x_val, float y_val, float z_val) : x(x_val), y(y_val), z(z_val) {}

    // Basic Operations
    Vector3 operator+(const Vector3 &other) const;
    Vector3 operator-(const Vector3 &other) const;
    Vector3 operator*(float scalar) const;
    Vector3 operator/(float scalar) const;

    // Compound Assignment Operators
    Vector3 &operator+=(const Vector3 &other);
    Vector3 &operator-=(const Vector3 &other);
    Vector3 &operator*=(float scalar);
    Vector3 &operator/=(float scalar);

    // Operator for element-wise multiplication
    Vector3 operator*(const Vector3 &other) const;

    // Unary Minus Operator
    Vector3 operator-() const;

    // Dot Product and Cross Product
    float dot(const Vector3 &other) const;
    Vector3 cross(const Vector3 &other) const;

    // Normalize vector
    Vector3 normalise() const;

    // Add operator[] for component access
    float &operator[](int index);
    const float &operator[](int index) const;

    // Static methods for min and max
    static Vector3 min(const Vector3 &a, const Vector3 &b);
    static Vector3 max(const Vector3 &a, const Vector3 &b);

    Vector3 reflect(const Vector3 &normal) const;
    Vector3 refract(const Vector3 &normal, float eta) const;

    // Length and Length Squared
    float length() const;
    float lengthSquared() const;

    // Clamp vector components between min and max
    Vector3 clamp(float min_val, float max_val) const;

    // Equality operators with tolerance for floating-point comparisons
    bool operator==(const Vector3 &other) const;
    bool operator!=(const Vector3 &other) const;

    // Stream insertion operator for printing
    friend std::ostream &operator<<(std::ostream &os, const Vector3 &v);

    // Debugging
    void print() const;
};

// Scalar * Vector3 multiplication (global operator overload)
inline Vector3 operator*(float scalar, const Vector3 &v)
{
    return Vector3(v.x * scalar, v.y * scalar, v.z * scalar);
}

#endif // VECTOR3_H

// Scene.h
#ifndef SCENE_H
#define SCENE_H

#include <vector>
#include <memory>
#include "Object.h"  // Base class for Sphere, Cylinder, Triangle
#include "Light.h"   // Light class
#include "Camera.h"  // Camera class
#include "Vector3.h" // Vector3 class for colors and positions
#include "BVHNode.h" // BVHNode class for acceleration structure

class Scene
{
public:
    // Constructor
    Scene() : backgroundColor(0.25f, 0.25f, 0.25f), renderMode("binary"), nbounces(1), bvhRoot(nullptr) {}

    // Scene components
    Camera camera;                                // Camera
    std::vector<std::shared_ptr<Object>> objects; // Collection of objects (polymorphic)
    std::vector<Light> lights;                    // Collection of lights
    Color backgroundColor;                        // Background color
    std::string renderMode;                       // Rendering mode (e.g., binary, phong, pathtracer)
    int nbounces;                                 // Number of bounces for reflections/refractions

    // Method to add an object
    void addObject(const std::shared_ptr<Object> &obj)
    {
        objects.push_back(obj);
    }

    // Method to add a light
    void addLight(const Light &light)
    {
        lights.push_back(light);
    }

    // Method to build the BVH tree
    void buildBVH();

    // Intersection method declaration
    bool intersect(const Ray &ray, Intersection &closestHit) const;

private:
    // Private members or helper methods if needed
    std::shared_ptr<BVHNode> bvhRoot; // Root of the BVH tree
};

#endif // SCENE_H

binary_primitives.json
{
    "rendermode":"binary",
    "camera":
        { 
            "type":"pinhole", 
            "width":1200, 
            "height":800,
            "position":[0.0, 0, 0],
            "lookAt":[0.0, 0, 1.0],
            "upVector":[0.0, 1.0, 0.0],
            "fov":45.0,
            "exposure":0.1
        },
    "scene":
        { 
            "backgroundcolor": [0.25, 0.25, 0.25], 
            "shapes":[ 
                { 
                    "type":"sphere", 
                    "center": [-0.3, 0.19, 1],
                    "radius":0.2
                },
                {
                    "type": "cylinder",
                    "center": [-0.3, -0.2, 1],
                    "axis": [1, 0, 0],
                    "radius": 0.15,
                    "height": 0.2
                },
                { 
                    "type":"triangle", 
                    "v0": [0, 0, 1],
                    "v1": [0.5, 0, 1],
                    "v2": [0.25,  0.25, 1]
                }  
            ] 
        } 
}

scene.json
{
  "nbounces": 8,
  "rendermode": "phong",
  "camera": {
    "type": "pinhole",
    "width": 1200,
    "height": 800,
    "position": [0.0, 0.75, -0.25],
    "lookAt": [0.0, 0.35, 1.0],
    "upVector": [0.0, 1.0, 0.0],
    "fov": 45.0,
    "exposure": 1.5
  },
  "scene": {
    "backgroundcolor": [0.25, 0.25, 0.25],
    "lightsources": [
      {
        "type": "pointlight",
        "position": [0, 1.0, 0.5],
        "intensity": [0.5, 0.5, 0.5]
      },
      {
        "type": "pointlight",
        "position": [0, 1.0, -0.5],
        "intensity": [0.5, 0.5, 0.5]
      }
    ],
    "shapes": [
      {
        "type": "sphere",
        "center": [0, -25.0, 0],
        "radius": 25.1,
        "material": {
          "ks": 0.1,
          "kd": 0.9,
          "specularexponent": 10,
          "diffusecolor": [0.5, 1, 0.5],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": false,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0
        }
      },
      {
        "type": "cylinder",
        "center": [-0.3, 0.19, 1],
        "axis": [0, 1, 0],
        "radius": 0.15,
        "height": 0.2,
        "material": {
          "ks": 0.1,
          "kd": 0.9,
          "specularexponent": 20,
          "diffusecolor": [0.5, 0.5, 0.8],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": false,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0
        }
      },
      {
        "type": "triangle",
        "v0": [0, 0.0, 2.25],
        "v1": [0.75, 0.0, 2],
        "v2": [0, 0.75, 2.25],
        "material": {
          "ks": 0.3,
          "kd": 0.9,
          "specularexponent": 2,
          "diffusecolor": [0.8, 0.5, 0.8],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": true,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0
        }
      },
      {
        "type": "triangle",
        "v0": [0.75, 0.75, 2],
        "v1": [0.75, 0.0, 2],
        "v2": [0, 0.75, 2.25],
        "material": {
          "ks": 0.3,
          "kd": 0.9,
          "specularexponent": 2,
          "diffusecolor": [0.8, 0.5, 0.8],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": true,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0
        }
      },
      {
        "type": "sphere",
        "center": [-0.3, 0.59, 1],
        "radius": 0.2,
        "material": {
          "ks": 0.1,
          "kd": 0.9,
          "specularexponent": 20,
          "diffusecolor": [0.8, 0.5, 0.5],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": false,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0
        }
      },
      {
        "type": "sphere",
        "center": [0.3, 0.29, 1],
        "radius": 0.2,
        "material": {
          "ks": 0.1,
          "kd": 0.9,
          "specularexponent": 20,
          "diffusecolor": [0.8, 0.5, 0.5],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": true,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0
        }
      }
    ]
  }
}

scene_texture.json
{
  "nbounces": 8,
  "rendermode": "binary",
  "camera": {
    "type": "pinhole",
    "width": 1200,
    "height": 800,
    "position": [0.0, 0.75, -0.25],
    "lookAt": [0.0, 0.35, 1.0],
    "upVector": [0.0, 1.0, 0.0],
    "fov": 45.0,
    "exposure": 0.1
  },
  "scene": {
    "backgroundcolor": [0.25, 0.25, 0.25],
    "lightsources": [
      {
        "type": "pointlight",
        "position": [0, 1.0, 0.5],
        "intensity": [0.5, 0.5, 0.5]
      },
      {
        "type": "pointlight",
        "position": [0, 1.0, -0.5],
        "intensity": [0.5, 0.5, 0.5]
      }
    ],
    "shapes": [
      {
        "type": "sphere",
        "center": [0, -25.0, 0],
        "radius": 25.1,
        "material": {
          "ks": 0.1,
          "kd": 0.9,
          "specularexponent": 10,
          "diffusecolor": [0.5, 1, 0.5],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": false,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0,
          "texture": {
            "type": "checkerboard",
            "color1": [0.5, 1, 0.5],
            "color2": [0.2, 0.4, 0.2],
            "scale": 10.0
          }
        }
      },
      {
        "type": "cylinder",
        "center": [-0.3, 0.19, 1],
        "axis": [0, 1, 0],
        "radius": 0.15,
        "height": 0.2,
        "material": {
          "ks": 0.1,
          "kd": 0.9,
          "specularexponent": 20,
          "diffusecolor": [0.5, 0.5, 0.8],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": false,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0,
          "texture": {
            "type": "checkerboard",
            "color1": [0.5, 0.5, 0.8],
            "color2": [0.2, 0.2, 0.4],
            "scale": 10.0
          }
        }
      },
      {
        "type": "triangle",
        "v0": [0, 0.0, 2.25],
        "v1": [0.75, 0.0, 2],
        "v2": [0, 0.75, 2.25],
        "uv0": [0.0, 0.0],
        "uv1": [1.0, 0.0],
        "uv2": [0.0, 1.0],
        "material": {
          "ks": 0.3,
          "kd": 0.9,
          "specularexponent": 2,
          "diffusecolor": [0.8, 0.5, 0.8],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": true,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0,
          "texture": {
            "type": "checkerboard",
            "color1": [0.8, 0.5, 0.8],
            "color2": [0.2, 0.1, 0.2],
            "scale": 5.0
          }
        }
      },
      {
        "type": "triangle",
        "v0": [0.75, 0.75, 2],
        "v1": [0.75, 0.0, 2],
        "v2": [0, 0.75, 2.25],
        "uv0": [1.0, 1.0],
        "uv1": [1.0, 0.0],
        "uv2": [0.0, 1.0],
        "material": {
          "ks": 0.3,
          "kd": 0.9,
          "specularexponent": 2,
          "diffusecolor": [0.8, 0.5, 0.8],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": true,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0,
          "texture": {
            "type": "checkerboard",
            "color1": [0.8, 0.5, 0.8],
            "color2": [0.2, 0.1, 0.2],
            "scale": 5.0
          }
        }
      },
      {
        "type": "sphere",
        "center": [-0.3, 0.59, 1],
        "radius": 0.2,
        "material": {
          "ks": 0.1,
          "kd": 0.9,
          "specularexponent": 20,
          "diffusecolor": [0.8, 0.5, 0.5],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": false,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0,
          "texture": {
            "type": "checkerboard",
            "color1": [0.8, 0.5, 0.5],
            "color2": [0.4, 0.25, 0.25],
            "scale": 10.0
          }
        }
      },
      {
        "type": "sphere",
        "center": [0.3, 0.29, 1],
        "radius": 0.2,
        "material": {
          "ks": 0.1,
          "kd": 0.9,
          "specularexponent": 20,
          "diffusecolor": [0.8, 0.5, 0.5],
          "specularcolor": [1.0, 1.0, 1.0],
          "isreflective": true,
          "reflectivity": 1.0,
          "isrefractive": false,
          "refractiveindex": 1.0,
          "texture": {
            "type": "checkerboard",
            "color1": [0.8, 0.5, 0.5],
            "color2": [0.4, 0.25, 0.25],
            "scale": 10.0
          }
        }
      }
    ]
  }
}

simple_phong.json
{
    "nbounces":8, 
    "rendermode":"phong",
    "camera":
        { 
            "type":"pinhole", 
            "width":1200, 
            "height":800,
            "position":[0.0, 1, -2],
            "lookAt":[0.0, -0.1, 1.0],
            "upVector":[0.0, 1.0, 0.0],
            "fov":45.0,
            "exposure":0.1
        },
    "scene":
        { 
            "backgroundcolor": [0.25, 0.25, 0.25], 
            "lightsources":[ 
                { 
                    "type":"pointlight", 
                    "position":[0, 1.0, 0.5], 
                    "intensity":[0.75, 0.75, 0.75] 
                }
            ], 
            "shapes":[ 
                { 
                    "type":"sphere", 
                    "center": [-0.35, -0.2, 1],
                    "radius":0.3, 
                    "material":
                        { 
                            "ks":0.1, 
                            "kd":0.9, 
                            "specularexponent":20, 
                            "diffusecolor":[0.8, 0.5, 0.5],
                            "specularcolor":[1.0,1.0,1.0],
                            "isreflective":false,
                            "reflectivity":1.0,
                            "isrefractive":false,
                            "refractiveindex":1.0 
                        } 
                },
                {
                    "type": "cylinder",
                    "center": [0.3, 0, 1],
                    "axis": [0, 1, 0],
                    "radius": 0.25,
                    "height": 0.5,
                    "material":
                        { 
                            "ks":0.1, 
                            "kd":0.9, 
                            "specularexponent":20, 
                            "diffusecolor":[0.5, 0.5, 0.8],
                            "specularcolor":[1.0,1.0,1.0],
                            "isreflective":false,
                            "reflectivity":1.0,
                            "isrefractive":false,
                            "refractiveindex":1.0 
                        } 
                },
                { 
                    "type":"triangle", 
                    "v0": [ -1, -0.5, 2],
                    "v1": [ 1, -0.5, 2],
                    "v2": [ 1, -0.5, 0],
                    "material":
                        { 
                            "ks":0.1, 
                            "kd":0.9, 
                            "specularexponent":20, 
                            "diffusecolor":[0.5, 0.8, 0.5],
                            "specularcolor":[1.0,1.0,1.0],
                            "isreflective":false,
                            "reflectivity":1.0,
                            "isrefractive":false,
                            "refractiveindex":1.0 
                        } 
                },
                { 
                    "type":"triangle", 
                    "v0": [-1, -0.5, 0],
                    "v1": [-1, -0.5, 2],
                    "v2": [ 1, -0.5, 0],
                    "material":
                        { 
                            "ks":0.1, 
                            "kd":0.9, 
                            "specularexponent":20, 
                            "diffusecolor":[0.5, 0.8, 0.5],
                            "specularcolor":[1.0,1.0,1.0],
                            "isreflective":false,
                            "reflectivity":1.0,
                            "isrefractive":false,
                            "refractiveindex":1.0 
                        } 
                }  
            ] 
        } 
}

mirror_image.json
{
    "nbounces":8, 
    "rendermode":"phong",
    "camera":
        { 
            "type":"pinhole", 
            "width":1200, 
            "height":800,
            "position":[-1, 0.5, -1.5],
            "lookAt":[0.25, -0.05, 1.0],
            "upVector":[0.0, 1.0, 0.0],
            "fov":45.0,
            "exposure":0.1
        },
    "scene":
        { 
            "backgroundcolor": [0.25, 0.25, 0.25], 
            "lightsources":[ 
                { 
                    "type":"pointlight", 
                    "position":[0, 1.0, 0.5], 
                    "intensity":[0.75, 0.75, 0.75] 
                }
            ], 
            "shapes":[ 
                { 
                    "type":"sphere", 
                    "center": [-0.35, -0.2, 1],
                    "radius":0.3, 
                    "material":
                        { 
                            "ks":0.1, 
                            "kd":0.9, 
                            "specularexponent":20, 
                            "diffusecolor":[0.8, 0.5, 0.5],
                            "specularcolor":[1.0,1.0,1.0],
                            "isreflective":false,
                            "reflectivity":1.0,
                            "isrefractive":false,
                            "refractiveindex":1.0 
                        } 
                },
                { 
                    "type":"sphere", 
                    "center": [0, 0.2, -1.25],
                    "radius":0.2, 
                    "material":
                        { 
                            "ks":0.1, 
                            "kd":0.9, 
                            "specularexponent":20, 
                            "diffusecolor":[0.8, 0.5, 0.8],
                            "specularcolor":[1.0,1.0,1.0],
                            "isreflective":false,
                            "reflectivity":1.0,
                            "isrefractive":false,
                            "refractiveindex":1.0 
                        } 
                },
                {
                    "type": "cylinder",
                    "center": [0.3, 0, 1],
                    "axis": [0, 1, 0],
                    "radius": 0.25,
                    "height": 0.5,
                    "material":
                        { 
                            "ks":0.1, 
                            "kd":0.9, 
                            "specularexponent":20, 
                            "diffusecolor":[0.5, 0.5, 0.8],
                            "specularcolor":[1.0,1.0,1.0],
                            "isreflective":false,
                            "reflectivity":1.0,
                            "isrefractive":false,
                            "refractiveindex":1.0 
                        } 
                },
                { 
                    "type":"triangle", 
                    "v0": [ -1, -0.5, 2],
                    "v1": [ 1, -0.5, 2],
                    "v2": [ 1, -0.5, 0],
                    "material":
                        { 
                            "ks":0.1, 
                            "kd":0.9, 
                            "specularexponent":20, 
                            "diffusecolor":[0.5, 0.8, 0.5],
                            "specularcolor":[1.0,1.0,1.0],
                            "isreflective":false,
                            "reflectivity":1.0,
                            "isrefractive":false,
                            "refractiveindex":1.0 
                        } 
                },
                { 
                    "type":"triangle", 
                    "v0": [-1, -0.5, 0],
                    "v1": [-1, -0.5, 2],
                    "v2": [ 1, -0.5, 0],
                    "material":
                        { 
                            "ks":0.1, 
                            "kd":0.9, 
                            "specularexponent":20, 
                            "diffusecolor":[0.5, 0.8, 0.5],
                            "specularcolor":[1.0,1.0,1.0],
                            "isreflective":false,
                            "reflectivity":1.0,
                            "isrefractive":false,
                            "refractiveindex":1.0 
                        } 
                },
                { 
                    "type":"triangle", 
                    "v0": [ -1, -0.5, 2],
                    "v1": [ 1, 2.5, 2],
                    "v2": [ 1, -0.5, 2],
                    "material":
                        { 
                            "ks":0.1, 
                            "kd":0.9, 
                            "specularexponent":20, 
                            "diffusecolor":[0.5, 0.8, 0.5],
                            "specularcolor":[1.0,1.0,1.0],
                            "isreflective":true,
                            "reflectivity":1.0,
                            "isrefractive":false,
                            "refractiveindex":1.0 
                        } 
                },
                { 
                    "type":"triangle", 
                    "v0": [ -1, -0.5, 2],
                    "v1": [ -1, 2.5, 2],
                    "v2": [ 1, 2.5, 2],
                    "material":
                        { 
                            "ks":0.1, 
                            "kd":0.9, 
                            "specularexponent":20, 
                            "diffusecolor":[0.5, 0.8, 0.5],
                            "specularcolor":[1.0,1.0,1.0],
                            "isreflective":true,
                            "reflectivity":1.0,
                            "isrefractive":false,
                            "refractiveindex":1.0 
                        } 
                }  
            ] 
        } 
}

# Set the compiler and flags
CXX = /opt/homebrew/bin/g++-14
CXXFLAGS = -std=c++17 -O3 -Wall -Wextra -Wpedantic -fopenmp \
           -Iinclude -Itest \
           -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX13.1.sdk
LDFLAGS = -L/opt/homebrew/lib/gcc/14

# Directories for source, test, and output files
SRC_DIR = src
TEST_DIR = test
OBJ_DIR = obj
BIN_DIR = bin

# List of source files and object files (excluding main.cpp for tests)
SOURCES = $(filter-out $(SRC_DIR)/main.cpp, $(wildcard $(SRC_DIR)/*.cpp))
OBJECTS = $(SOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)
MAIN_OBJECT = $(OBJ_DIR)/main.o

# List of test sources and objects
TEST_SOURCES = $(filter-out $(SRC_DIR)/main.cpp, $(SOURCES)) \
               $(TEST_DIR)/test_camera.cpp $(TEST_DIR)/test_sphere.cpp $(TEST_DIR)/test_ray.cpp \
               $(TEST_DIR)/catch_amalgamated.cpp
TEST_OBJECTS = $(TEST_SOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)

# Executable targets
TARGET = $(BIN_DIR)/raytracer
TEST_TARGET_CAMERA = $(BIN_DIR)/test_camera
TEST_TARGET_SPHERE = $(BIN_DIR)/test_sphere
TEST_TARGET_RAY = $(BIN_DIR)/test_ray
TEST_TARGET_TRIANGLE = $(BIN_DIR)/test_triangle
TEST_TARGET_CYLINDER = $(BIN_DIR)/test_cylinder
TEST_TARGET_SHADOW = $(BIN_DIR)/test_shadow
TEST_TARGET_SCENE_LOADER = $(BIN_DIR)/test_scene_loader
TEST_TARGET_RAYTRACER = $(BIN_DIR)/test_raytracer
TEST_TARGET_BINARY_RENDERING_MODE = $(BIN_DIR)/test_binary_rendering_mode

# Default target to build the main executable
all: $(TARGET)

# Link object files to create the main executable
$(TARGET): $(OBJECTS) $(MAIN_OBJECT) | $(BIN_DIR)
	$(CXX) $(CXXFLAGS) -o $@ $^ $(LDFLAGS)

# Build and run the test_camera executable
test_camera: $(OBJECTS) $(OBJ_DIR)/test_camera.o $(OBJ_DIR)/catch_amalgamated.o | $(BIN_DIR)
	$(CXX) $(CXXFLAGS) -o $(TEST_TARGET_CAMERA) $(OBJECTS) $(OBJ_DIR)/test_camera.o $(OBJ_DIR)/catch_amalgamated.o $(LDFLAGS)
	./$(TEST_TARGET_CAMERA)

# Build and run the test_sphere executable
test_sphere: $(OBJECTS) $(OBJ_DIR)/test_sphere.o $(OBJ_DIR)/catch_amalgamated.o | $(BIN_DIR)
	$(CXX) $(CXXFLAGS) -o $(TEST_TARGET_SPHERE) $(OBJECTS) $(OBJ_DIR)/test_sphere.o $(OBJ_DIR)/catch_amalgamated.o $(LDFLAGS)
	./$(TEST_TARGET_SPHERE)

# Build and run the test_ray executable
test_ray: $(OBJECTS) $(OBJ_DIR)/test_ray.o $(OBJ_DIR)/catch_amalgamated.o | $(BIN_DIR)
	$(CXX) $(CXXFLAGS) -o $(TEST_TARGET_RAY) $(OBJECTS) $(OBJ_DIR)/test_ray.o $(OBJ_DIR)/catch_amalgamated.o $(LDFLAGS)
	./$(TEST_TARGET_RAY)

# Compile and run the test_triangle executable
test_triangle: $(OBJECTS) $(OBJ_DIR)/test_triangle.o $(OBJ_DIR)/catch_amalgamated.o | $(BIN_DIR)
	$(CXX) $(CXXFLAGS) -o $(TEST_TARGET_TRIANGLE) $(OBJECTS) $(OBJ_DIR)/test_triangle.o $(OBJ_DIR)/catch_amalgamated.o $(LDFLAGS)
	./$(TEST_TARGET_TRIANGLE)

# Compile and run the test_cylinder executable
test_cylinder: $(OBJECTS) $(OBJ_DIR)/test_cylinder.o $(OBJ_DIR)/catch_amalgamated.o | $(BIN_DIR)
	$(CXX) $(CXXFLAGS) -o $(TEST_TARGET_CYLINDER) $(OBJECTS) $(OBJ_DIR)/test_cylinder.o $(OBJ_DIR)/catch_amalgamated.o $(LDFLAGS)
	./$(TEST_TARGET_CYLINDER)

# Compile and run the test_shadow executable
test_shadow: $(OBJECTS) $(OBJ_DIR)/test_shadow.o $(OBJ_DIR)/catch_amalgamated.o | $(BIN_DIR)
	$(CXX) $(CXXFLAGS) -o $(TEST_TARGET_SHADOW) $(OBJECTS) $(OBJ_DIR)/test_shadow.o $(OBJ_DIR)/catch_amalgamated.o $(LDFLAGS)
	./$(TEST_TARGET_SHADOW)

# Rule for compiling and running the test_scene_loader executable
test_scene_loader: $(OBJECTS) $(OBJ_DIR)/test_scene_loader.o $(OBJ_DIR)/catch_amalgamated.o | $(BIN_DIR)
	$(CXX) $(CXXFLAGS) -o $(TEST_TARGET_SCENE_LOADER) $(OBJECTS) $(OBJ_DIR)/test_scene_loader.o $(OBJ_DIR)/catch_amalgamated.o $(LDFLAGS)
	./$(TEST_TARGET_SCENE_LOADER)

# Compile and run the test_raytracer executable
test_raytracer: $(OBJECTS) $(OBJ_DIR)/test_raytracer.o $(OBJ_DIR)/catch_amalgamated.o | $(BIN_DIR)
	$(CXX) $(CXXFLAGS) -o $(TEST_TARGET_RAYTRACER) $(OBJECTS) $(OBJ_DIR)/test_raytracer.o $(OBJ_DIR)/catch_amalgamated.o $(LDFLAGS)
	./$(TEST_TARGET_RAYTRACER)

# Compile and run the test_binary_rendering_mode executable
test_binary_rendering_mode: $(OBJECTS) $(OBJ_DIR)/test_binary_rendering_mode.o $(OBJ_DIR)/catch_amalgamated.o | $(BIN_DIR)
	$(CXX) $(CXXFLAGS) -o $(TEST_TARGET_BINARY_RENDERING_MODE) $(OBJECTS) $(OBJ_DIR)/test_binary_rendering_mode.o $(OBJ_DIR)/catch_amalgamated.o $(LDFLAGS)
	./$(TEST_TARGET_BINARY_RENDERING_MODE)

# Compile each .cpp file in src to an object file (including main.cpp)
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp | $(OBJ_DIR)
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Compile each .cpp file in test to an object file
$(OBJ_DIR)/%.o: $(TEST_DIR)/%.cpp | $(OBJ_DIR)
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Ensure output directories exist
$(BIN_DIR) $(OBJ_DIR):
	mkdir -p $@

# Clean command to remove generated files
clean:
	rm -rf $(OBJ_DIR) $(BIN_DIR) *.o *.gch

// test_raytracer.cpp

#define CATCH_CONFIG_MAIN
#include "catch_amalgamated.hpp"

#include "Raytracer.h"
#include "Camera.h"
#include "SceneLoader.h"
#include "Vector3.h"
#include "Color.h"
#include "Scene.h"
#include "Sphere.h"
#include "Cylinder.h"
#include "Triangle.h"
#include <cmath>
#include <memory>
#include <iostream> // Include for printing

const float tolerance = 0.15f; // Increased tolerance for flexibility

// Function to compare two colors within a specified tolerance using Euclidean distance
bool areColorsSimilar(const Color &c1, const Color &c2, float tolerance)
{
    float dr = c1.r - c2.r;
    float dg = c1.g - c2.g;
    float db = c1.b - c2.b;
    float distance = std::sqrt(dr * dr + dg * dg + db * db);
    return distance < tolerance;
}

// Functions to check for expected colors based on Phong shading
bool isSphereColor(const Color &c)
{
    // Updated expected sphere color based on calculations
    Color expected(1.0f, 0.88f, 0.88f);
    return areColorsSimilar(c, expected, tolerance);
}

bool isCylinderColor(const Color &c)
{
    // Expected cylinder color based on ambient and diffuse components
    // Example calculation: (0.79f, 0.79f, 1.0f)
    Color expected(0.79f, 0.79f, 1.0f);
    return areColorsSimilar(c, expected, tolerance);
}

bool isTriangleColor(const Color &c)
{
    // Expected triangle color based on ambient, diffuse, and specular components
    // Example calculation: (0.89f, 1.0f, 0.89f)
    Color expected(0.89f, 1.0f, 0.89f);
    return areColorsSimilar(c, expected, tolerance);
}

TEST_CASE("Raytracer binary render mode produces expected output", "[RAYTRACER][binary]")
{
    // Load the binary scene
    SceneLoader sceneLoader;
    Scene scene;
    REQUIRE(sceneLoader.loadScene("scenes/binary_primitives.json", scene) == true); // Using binary_primitives.json

    // Retrieve camera dimensions from the loaded scene
    int width = scene.camera.width;
    int height = scene.camera.height;

    // Initialize Raytracer with camera's width and height
    Raytracer raytracer(width, height);

    // Render the scene
    raytracer.render(scene, "binary_test_output.ppm");

    // Define expected colors for binary mode
    Color backgroundColor(0.25f, 0.25f, 0.25f); // From binary_primitives.json
    Color white(1.0f, 1.0f, 1.0f);              // Binary mode: white for any intersection

    // Track if we find white and background color
    bool foundWhite = false, foundBackground = false;

    // Check each pixel for expected colors
    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            Color pixelColor = raytracer.getPixelColor(x, y);

            // Optionally, comment out to reduce console output
            // std::cout << "Binary Pixel (" << x << ", " << y << "): ("
            //           << pixelColor.r << ", " << pixelColor.g << ", " << pixelColor.b << ")\n";

            if (areColorsSimilar(pixelColor, backgroundColor, tolerance))
                foundBackground = true;
            else if (areColorsSimilar(pixelColor, white, tolerance))
                foundWhite = true;
        }
    }

    // Verify that at least one white and one background color pixel are found
    REQUIRE(foundWhite);
    REQUIRE(foundBackground);
}

TEST_CASE("Raytracer produces expected colors for intersections in Phong mode", "[RAYTRACER][phong]")
{
    // Load the Phong scene
    SceneLoader sceneLoader;
    Scene scene;
    REQUIRE(sceneLoader.loadScene("scenes/simple_phong.json", scene) == true); // Using simple_phong.json

    // Retrieve camera dimensions from the loaded scene
    int width = scene.camera.width;
    int height = scene.camera.height;

    // Initialize Raytracer with camera's width and height
    Raytracer raytracer(width, height);

    // Build the BVH for the scene
    scene.buildBVH();

    // Render the scene
    raytracer.render(scene, "phong_test_output.ppm");

    // Define expected colors based on material properties and lighting calculations
    Color backgroundColor(0.25f, 0.25f, 0.25f); // From simple_phong.json
    Color sphereColor(1.0f, 0.88f, 0.88f);      // Expected sphere color (updated)
    Color cylinderColor(0.79f, 0.79f, 1.0f);    // Expected cylinder color
    Color triangleColor(0.89f, 1.0f, 0.89f);    // Expected triangle color (updated)

    // Track if we find each color
    bool foundBackground = false, foundSphere = false, foundCylinder = false, foundTriangle = false;
    int triangleColorMatches = 0;
    int sphereColorMatches = 0;
    int cylinderColorMatches = 0;

    // Check each pixel for expected colors
    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            Color pixelColor = raytracer.getPixelColor(x, y);

            // Optionally, comment out to reduce console output
            // std::cout << "Phong Pixel (" << x << ", " << y << "): ("
            //           << pixelColor.r << ", " << pixelColor.g << ", " << pixelColor.b << ")\n";

            if (areColorsSimilar(pixelColor, backgroundColor, tolerance))
                foundBackground = true;
            else if (isSphereColor(pixelColor))
            {
                foundSphere = true;
                sphereColorMatches++;
                // Print first 5 sphere pixels for debugging
                if (sphereColorMatches <= 5)
                {
                    std::cout << "Sphere Pixel Found at (" << x << ", " << y << "): ("
                              << pixelColor.r << ", " << pixelColor.g << ", " << pixelColor.b << ")\n";
                }
            }
            else if (isCylinderColor(pixelColor))
            {
                foundCylinder = true;
                cylinderColorMatches++;
            }
            else if (isTriangleColor(pixelColor))
            {
                foundTriangle = true;
                triangleColorMatches++;
                // Print first 5 triangle pixels for debugging
                if (triangleColorMatches <= 5)
                {
                    std::cout << "Triangle Pixel Found at (" << x << ", " << y << "): ("
                              << pixelColor.r << ", " << pixelColor.g << ", " << pixelColor.b << ")\n";
                }
            }
            else
            {
                // Optionally, print unknown colors for debugging
                // std::cout << "Unknown Pixel (" << x << ", " << y << "): ("
                //           << pixelColor.r << ", " << pixelColor.g << ", " << pixelColor.b << ")\n";
            }
        }
    }

    // Print the number of pixels found for each object
    std::cout << "Number of Sphere Pixels Found: " << sphereColorMatches << "\n";
    std::cout << "Number of Cylinder Pixels Found: " << cylinderColorMatches << "\n";
    std::cout << "Number of Triangle Pixels Found: " << triangleColorMatches << "\n";

    // Verify that each expected color was found
    REQUIRE(foundBackground);
    REQUIRE(foundSphere);
    REQUIRE(foundCylinder);
    REQUIRE(foundTriangle);
}

